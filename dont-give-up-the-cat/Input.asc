// new module script
static InputParams* InputParams::NewInputParams(float turn_speed, float max_speed_forward, float  max_speed_forward_road, float  max_speed_forward_dirt, float max_speed_backward)
{
  InputParams* ip = new InputParams;
  ip.TurnSpeed = turn_speed;
  ip.MaxSpeedForward = max_speed_forward;
  ip.MaxSpeedForwardRoad = max_speed_forward_road;
  ip.MaxSpeedForwardDirt = max_speed_forward_dirt;
  ip.MaxSpeedBackward = max_speed_backward;
  return ip;
}

int _screen_middle_v;
int _screen_middle_h;

int mouse_delta_x, mouse_delta_y;
int mx;
int my;

void _adjust_delta()
{
  mx = mouse.x;
  my = mouse.y;
  
  _screen_middle_v = VIEW_SCREEN_HEIGHT/2;
  _screen_middle_h = VIEW_SCREEN_WIDTH/2;
  
  mouse_delta_x = mx - _screen_middle_h;
  mouse_delta_y = my - _screen_middle_v;
  
  if(AbsI(mouse_delta_y) < 2) mouse_delta_y = 0;
  if(AbsI(mouse_delta_x) < 1) mouse_delta_x = 0;
  
  mouse.SetPosition(_screen_middle_h, _screen_middle_v);
}

void input_car(Mode7Object* m7o_car, InputParams* p) {
  _adjust_delta();  
  
  m7o_car.Angle += IntToFloat(mouse_delta_x)/4.0;
  p.AngleX += IntToFloat(mouse_delta_y)/4.0;
  
  // steer kart
  float factor;
  float max_factor = 1.5;
  if (p.CurrentSpeed == 0.0) factor = 0.0;
  else factor = 0.9 * p.MaxSpeedForward / p.CurrentSpeed;
  if (factor > max_factor) factor = max_factor;
  if (factor < -max_factor) factor = -max_factor;
  
  // move kart
  float sin = Maths.Sin(Maths.DegreesToRadians(m7o_car.Angle));
  float cos = Maths.Cos(Maths.DegreesToRadians(m7o_car.Angle));
  
  if (IsKeyPressed(eKeyA)) m7o_car.Angle -= p.TurnSpeed * factor;
  if (IsKeyPressed(eKeyD)) m7o_car.Angle += p.TurnSpeed * factor;
  
  float target_speed = 0.0;
  if (IsKeyPressed(eKeyW) && !IsKeyPressed(eKeyS)) {
    target_speed = p.MaxSpeedForward;
  }
  if (IsKeyPressed(eKeyS) && !IsKeyPressed(eKeyW)) {
    if (p.CurrentSpeed <= 0.4) target_speed = -p.MaxSpeedBackward;
  }
  p.CurrentSpeed += (target_speed - p.CurrentSpeed) * 0.05;
  if (p.CurrentSpeed > -0.1 && p.CurrentSpeed < 0.1) p.CurrentSpeed = 0.0;
  
  m7o_car.X += p.CurrentSpeed * sin;
  m7o_car.Z -= p.CurrentSpeed * cos;
}

int _jump;
void input_player(Mode7Object* m7o_player, InputParams* p) {
  _adjust_delta();  
  
  m7o_player.Angle += IntToFloat(mouse_delta_x)/4.0;
  p.AngleX += IntToFloat(mouse_delta_y)/4.0;
  
  // steer kart
  float factor;
  float max_factor = 1.5;
  if (p.CurrentSpeed == 0.0) factor = 0.0;
  else factor = 0.9 * p.MaxSpeedForward / p.CurrentSpeed;
  if (factor > max_factor) factor = max_factor;
  if (factor < -max_factor) factor = -max_factor;
  
  // move kart
  float sin = Maths.Sin(Maths.DegreesToRadians(m7o_player.Angle));
  float cos = Maths.Cos(Maths.DegreesToRadians(m7o_player.Angle));
  
  if(m7o_player.Y > 0.0) {
    m7o_player.Y -= 2.5;
    if(m7o_player.Y <= 0.0) {
      m7o_player.Y = 0.0;
      _jump = 0;
    }
  }
  if(IsKeyPressed(eKeySpace) && (m7o_player.Y == 0.0 || _jump < 8)){
    float impulse_y = 10.0 - IntToFloat(_jump)/2.0;
    m7o_player.Y += 10.0;
    _jump++;
  }
    
  if (IsKeyPressed(eKeyA) || IsKeyPressed(eKeyD)) { 
    float side_step = 0.5;  
    float sin_ortho, cos_ortho;
    if(IsKeyPressed(eKeyA)) {
      sin_ortho = Maths.Sin(Maths.DegreesToRadians(m7o_player.Angle)-Maths.Pi/2.0);
      cos_ortho = Maths.Cos(Maths.DegreesToRadians(m7o_player.Angle)-Maths.Pi/2.0);
    }
    if (IsKeyPressed(eKeyD)) {
      sin_ortho = Maths.Sin(Maths.DegreesToRadians(m7o_player.Angle)+Maths.Pi/2.0);
      cos_ortho = Maths.Cos(Maths.DegreesToRadians(m7o_player.Angle)+Maths.Pi/2.0);
    }
      
    float next_x = m7o_player.X + side_step * sin_ortho;
    float next_z = m7o_player.Z - side_step * cos_ortho;   
    
    int next_map_x = FloatToInt(IntToFloat(Room.Width/2) + next_x);
    int next_map_y = FloatToInt(IntToFloat(Room.Height/2) + next_z);
  
    if(!IsWallAtRoomXY(next_map_x, next_map_y)) {   
      m7o_player.X = next_x;
      m7o_player.Z = next_z;
    }
  }
    
  float target_speed = 0.0;
  if (IsKeyPressed(eKeyW) && !IsKeyPressed(eKeyS)) {
    target_speed = p.MaxSpeedForward;
  }
  if (IsKeyPressed(eKeyS) && !IsKeyPressed(eKeyW)) {
    if (p.CurrentSpeed <= 0.4) target_speed = -p.MaxSpeedBackward;
  }
  p.CurrentSpeed += (target_speed - p.CurrentSpeed) * 0.05;
  
  if (p.CurrentSpeed > -0.1 && p.CurrentSpeed < 0.1) {
    p.CurrentSpeed = 0.0;
    return;
  }
  
  float next_x = m7o_player.X + p.CurrentSpeed * sin;
  float next_z = m7o_player.Z - p.CurrentSpeed * cos;
  
  int next_map_x = FloatToInt(IntToFloat(Room.Width/2) + next_x);
  int next_map_y = FloatToInt(IntToFloat(Room.Height/2) + next_z);
  
  if(IsWallAtRoomXY(next_map_x, next_map_y)) return;
  
  m7o_player.X = next_x;
  m7o_player.Z = next_z;  
}

// called when a mouse button is clicked
function on_mouse_click(MouseButton button)
{
  if (IsGamePaused())
  {
    // game is paused, so do nothing (i.e. don't process mouse clicks)
  }
  else if (button == eMouseLeft)
  {
    // left-click, so try using the current mouse cursor mode at this position
   // Room.ProcessClick(mouse.x, mouse.y, mouse.Mode);
  }
  else if (button == eMouseRight)
  {
    // right-click, so cycle the mouse cursor mode
   // mouse.SelectNextMode();
  }
}